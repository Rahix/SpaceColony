// Gamestate model for SpaceColony
// I am not shure wether this should be a part of the controller or a model, but I think it is
// better if it is a model because the render engine has to be able to acess it.
//
// (c) 2015 Rahix
use std::cmp::Eq;
use std::cmp::PartialEq;

pub mod GameState {
    pub enum States {
        NoState,
        Initializing,
        MainMenu,
        OptionsMenu,
        InGame
    }

    // This code was written in hate to somebody who didn't made rust enums comparable >:-(
    // EQ-Trait-Implementation ---- {{{
    //                           _,..__,
    //                       ,.'''      `"-,_
    //                     ,'                '.
    //                   ,'                    '
    //                  /                       \_
    //                 ;     -.                   `\
    //                 |       |     _         _    .
    //                ;       ,'  ,-' `.     /' `.  |
    //                |       '  /  o   |   t  o  \.'    .,-.
    //                 |         |:    .'   |:    .|    /    \
    //                 ;         \:.._./    ':_..:/ `. |      L
    //                  \  ,-'           |\_         `\-     "'-.
    //      ,-"'``'-,    `f              '/`>                    `.
    //    ,'        `L___.|              '  `     . _,/            \
    //    |                \_          _   _    .-.]____,,r        |
    //    \             ,. ___""----./` \,' ',`\'  \      \     mx.'
    //      `'-'|        '`         `|   |   |  |  |       `'--"'`
    //          ,         |           L_.'.__:__.-'
    //           \        /
    //            `'-- "'`
    //
    // (http://www.myrkraverk.com/ascii/)
    impl PartialEq<States> for States {
        fn eq(&self, other: &States) -> bool {
            false
        }
    }

    impl Eq for States {}
    // }}}

    pub struct ChangeAction {
        new_state: States,
        last_state: States,
        simple: bool,
        action: fn()
    }

    impl ChangeAction {
        pub fn new(new_state: States, action: fn()) -> ChangeAction {
            ChangeAction {
                new_state: new_state,
                last_state: States::NoState,
                simple: true,
                action: action
            }
        }

        pub fn add_last(&mut self, last_state: States) {
            self.last_state = last_state;
            self.simple = false;
        }

        pub fn new_with_last(new_state: States, last_state: States, action: fn()) -> ChangeAction {
            ChangeAction {
                new_state: new_state,
                last_state: last_state,
                simple: false,
                action: action
            }
        }

        pub fn run_action(&self) {
            let action = self.action;
            action();
        }
    }

    pub struct GameState {
        current_state: States,
        last_state: States,
        change_actions: Vec<ChangeAction>
    }

    impl GameState {
        pub fn new() -> GameState {
            GameState {
                current_state: States::NoState,
                last_state: States::NoState,
                change_actions: Vec::new()
            }
        }

        pub fn register_change_action(&mut self, action: ChangeAction) {
            self.change_actions.push(action);
        }

        fn trigger_change_actions(&mut self) {
            // Iterate through change actions and call all which match current state constitution
            for action in self.change_actions.iter() {
                if((action.new_state == self.current_state)
                   && (action.simple == true)) {
                    action.run_action();
                }
                if((action.new_state == self.current_state)
                   && (action.last_state == self.last_state)
                   && (action.simple == false)) {
                   action.run_action();
                }
            }
        }

        pub fn trigger_state_change(&mut self, new_state: States) {
            self.last_state = self.current_state.clone();
            self.current_state = new_state;
            // Trigger change actions
            self.trigger_change_actions();
        }
    }
}
